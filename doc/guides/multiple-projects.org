#+TITLE: Multiple Projects

=floco= was designed to make managing multiple local projects
easy, in fact it was originally designed to allow "recursive
local builds" in a way that =yarn= and =npm= really struggle
to provide.

The summary of this article for a =project-a= that depends on
=project-b= is basically:
#+BEGIN_SRC nix
{
  _file   = "project-a/floco-cfg.nix";
  imports = [
    ./pdefs.nix
    ./foverrides.nix
    ../project-b/floco-cfg.nix
  ];
}
#+END_SRC

* Files

The convention of organizating generated configs in
=pdefs.{json,nix}=, manual configuration in =foverrides.nix=,
and project/file organization in =floco-cfg.nix=
is recommended.

** =_file= Field

While the =_file= field is optional, it is strongly 
recommended and the modules for certain records are sensitive
to filenames.
By setting =_file= explicitly you'll ensure that backtraces
and deserialization of configs use the given name regardless
of the "real" filename which can help avoid pitfalls.
 
The files =floco-cfg.{nix,json}=, =pdefs.{nix,json}=, and
=foverrides.{nix,json}= specifically are treated specifically.
At time of writing only the =pdef= record is sensitive to
filenames, but more
[[https://github.com/aakropotkin/floco/blob/main/modules/records/pdef/implementation.nix#L76][deserialized]]
sensitive records may be added in the future.

For JSON files or other non-nix formats you must explicitly
set =_file= in an inline module.
The routine =lib.modules.importJSON= is a shorthand for this,
but the following two includes are equivalent:
#+BEGIN_SRC nix
{
  _file = "foo/floco-cfg.nix";
  imports = [
    ( { _file = ./foo/pdefs.json; } //
      ( lib.importJSON ./pdefs.json ) )
      
    ( lib.modules.importJSON ./foverrides.json )
  ];
}
#+END_SRC

When including JSON and other formats you should remember
the way "shorthand" configs get processed and you make
sure that you don't accidentally define
~config.config.foo = 1;~.

** =imports= Field

Imports are a module field containing paths to or inline
definitions of modules that will be merged with the
current module.

This field is special in the module system because it must
be processed before =config= and generally cannot refer
to any arguments other than =lib=.
=deferredModule= is an exception to this rule, and is
used to define configurable records.

=imports= may be defined for submodules as well, not just
the top level module.
This can be useful for recycling common code to be applied
to =pdef= or =package= records.


* Merged Build Plan

When multiple files or projects are combined with =imports=
the module system merges definitions of attrsets and types
recursively using rules defined in options' type definitions.

The
[[https://nixos.org/manual/nixos/stable/#sec-writing-modules][NixOS manual]]
is the best resource for learning about
merges, but I cover some fundamentals and notable types
in =floco= that use custom merge routines in the
[[https://github.com/aakropotkin/floco/blob/main/doc/guides/module-system.org][Module System]]
guide.
This section will assume that you have already made yourself familiar with
how configurations are merged "generally" and "priorities".

** Handling Conflicts

When combining multiple projects' generated configs the most common area to
run into conflicting metadata is in =depInfo.<IDENT>.pin= fields.
Other fields to watch out for are =fetchInfo.path=, =treeInfo=, =ltype=,
and =depInfo=.

*** Merging =depInfo.<IDENT>.pin= fields

This type has a custom =merge= function which breaks conflicts by
preferring the "highest" semantic version number.

These pins may be used by submodules that attempt to generate =treeInfo=
records when they are undefined, but remember that they will NOT have any
effect on configurations which explicitly define =treeInfo= records.
